<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Van</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			position: relative;
			/* background-color: #333333; */
			background: linear-gradient(180deg, #fff 60%, #e4e4e4) !important;
			margin: 0;
			color: #333;
			font-family: Monospace;
			font-size: 13px;
			line-height: 24px;
			overscroll-behavior: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

		.d-flex {
			display: flex;
		}

		.items-container {
			position: absolute;
			bottom: 16px;
			left: 50%;
			transform: translateX(-50%);
		}

		.item-box {
			margin-left: 8px;
			margin-right: 8px;
			border-radius: 15px;
			text-align: center;
			cursor: grab;
			opacity: 0.8;
			transition: opacity .15s ease-in-out, transform .08s linear;
		}

		.item-box:active {
			cursor: grabbing;
			cursor: -moz-grabbing;
			cursor: -webkit-grabbing;
		}

		.item-box:hover {
			opacity: 1;
			transform: scale(1.04);
		}

		.item-img {
			width: 100px;
			height: 100px;
			border-radius: 15px;
			background-size: cover;
			box-shadow: 0.6px 0.6px 1.9px rgba(0, 0, 0, .035), 5px 5px 15px rgba(0, 0, 0, .07);
		}

		p {
			font-size: 11px;
			line-height: 1.5;
			margin-bottom: 12px;
		}

		#airconditioner {
			background-image: url(images/airconditioner.jpg);
		}

		#maxxair {
			background-image: url(images/maxxair.jpg);
		}

		#solar_panel200 {
			background-image: url(images/200W.jpg);
		}

		#solar_panel50 {
			background-image: url(images/55W.jpg);
		}

		#solar_panel30 {
			background-image: url(images/30W.jpg);
		}

		button {
			cursor: pointer;
		}

		#deleteButton {
			display: none;
			justify-content: center;
			align-items: center;
			background-color: transparent;
			border: 0;
			cursor: pointer;
			color: #333;
			padding: 8px;
			margin: 0 10px 8px auto;
			opacity: 0.8;
			transition: opacity ease .3s;
		}

		#deleteButton:hover {
			opacity: 1;
		}

		#deleteButton svg {
			padding-right: 4px;
		}

		.action-btn-list {
			position: absolute;
			bottom: 125px;
			right: 16px;
		}

		.action-btn-list button {
			width: 40px;
			height: 40px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: #333;
			border-radius: 22px;
			border: none;
		}
	</style>
</head>

<body>
	<div class="items-container">
		<div>
			<button id="deleteButton">
				<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 40 40">
					<path fill="#333333"
						d="M21.499 19.994L32.755 8.727a1.064 1.064 0 0 0-.001-1.502c-.398-.396-1.099-.398-1.501.002L20 18.494L8.743 7.224c-.4-.395-1.101-.393-1.499.002a1.05 1.05 0 0 0-.309.751c0 .284.11.55.309.747L18.5 19.993L7.245 31.263a1.064 1.064 0 0 0 .003 1.503c.193.191.466.301.748.301h.006c.283-.001.556-.112.745-.305L20 21.495l11.257 11.27c.199.198.465.308.747.308a1.058 1.058 0 0 0 1.061-1.061c0-.283-.11-.55-.31-.747z" />
				</svg>
				Delete
			</button>
		</div>
		<div class="d-flex">
			<div class="item-box">
				<div class="item-img" id="airconditioner" draggable="true"></div>
				<div class="item-name">
					<p>Air Conditioner</p>
				</div>
			</div>
			<div class="item-box">
				<div class="item-img" id="maxxair" draggable="true"></div>
				<div class="item-name">
					<p>Maxxair</p>
				</div>
			</div>
			<div class="item-box">
				<div class="item-img" id="solar_panel200" draggable="true"></div>
				<div class="item-name">
					<p>Solar Panel<br />(200W)</p>
				</div>
			</div>
			<div class="item-box">
				<div class="item-img" id="solar_panel50" draggable="true"></div>
				<div class="item-name">
					<p>Solar Panel<br />(55W)</p>
				</div>
			</div>
			<div class="item-box">
				<div class="item-img" id="solar_panel30" draggable="true"></div>
				<div class="item-name">
					<p>Solar Panel<br />(30W)</p>
				</div>
			</div>
		</div>

	</div>
	<div class="action-btn-list">
		<button id="camChangeBtn">
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 72 72">
				<circle cx="22.258" cy="26.11" r="3" fill="#ffffff" />
				<circle cx="46.153" cy="26.11" r="3" fill="#ffffff" />
				<path fill="none"
					d="M46.153 16.11c-5.514 0-10 4.486-10 10s4.486 10 10 10s10-4.485 10-10s-4.485-10-10-10m0 13c-1.654 0-3-1.346-3-3s1.346-3 3-3s3 1.346 3 3s-1.345 3-3 3m-23.895-13c-5.514 0-10 4.486-10 10s4.486 10 10 10s10-4.485 10-10c0-5.514-4.486-10-10-10m0 13c-1.655 0-3-1.346-3-3s1.345-3 3-3s3 1.346 3 3s-1.346 3-3 3m-1.829 15.127l6.998.815c.376-.147 2.842-.37 2.842-.37s2.814 1.782 3.188 4.571c.375 2.79-4.643 3.815-4.869 3.815c-2.515 0-3.628-4.56-3.632-4.603l-4.527-.695l.57 2.249c.285 1.13.424 2.292.413 3.458l-.016 1.613c0 .447 1.387 1.808 1.865 1.808h24.826V40.031H20.43z" />
				<path fill="#fff" d="m51.727 42.827l-.005.003l.164-.057z" />
				<path fill="#fff"
					d="m61.183 54.97l-.238-13.608s-9.289 1.498-9.246 1.482c.008-.003.015-.01.023-.014l-3.445.983v9.22l3.629 1.034l-.142-.043c-.018-.005 9.418.946 9.418.946" />
				<path fill="#ffffff"
					d="M24.218 48.465c.113.02 2.597 3.539 2.675 3.603c.064.054 3.39 1.027 3.602 1c.21-.029 2.295-2.027 2.353-2.135c.019-.034 1.175-1.76.83-3.2c-.243-1.01-2.005-1.881-2.07-1.93c-.158-.121-3.69-.735-3.7-.737c0 0-15.537-2.56-15.65-2.638l-4.365-3.515l-1.332 8.05l4.745-.735c.111-.017 12.912 2.236 12.912 2.236" />
				<g fill="none" stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
					<path d="M21.396 40.03h26.692v16.868H23.26c-1.03 0-1.865-.81-1.865-1.808v-3.124" />
					<path
						d="m7.915 39.39l-1.152 7.573l5.017-.779l13.594 2.492a4.105 4.105 0 1 0 2.359-3.435l-15.268-2.799z" />
					<circle cx="46.154" cy="26.11" r="10" />
					<circle cx="46.154" cy="26.11" r="3" />
					<circle cx="22.258" cy="26.11" r="10" />
					<circle cx="22.258" cy="26.11" r="3" />
					<path d="m52.053 53.068l8.892 2.113v-13.82l-8.892 2.412" />
				</g>
			</svg>
		</button>
	</div>
	<div id="container"></div>

	<script type="module">

		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { ViewHelper } from 'three/addons/helpers/ViewHelper.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

		// import { OBB } from 'three/examples/jsm/math/OBB'

		let canvas, camera, scene, renderer;
		let cameraType = "perspective";
		let canvasContainer = document.getElementById("container");

		let grid;
		let controls;

		let selectedFeature;
		var targetForDragging;

		let isDragging = false;

		let intersects;
		let raycaster;
		let workPlane;

		let edges;
		let line;
		let edgeLine = null;
		const lineMaterial = new THREE.LineBasicMaterial({ color: "#fff" });

		let vanItem;
		let cloneVanItem = null;
		let loadItemDirectory;

		let carModel;
		let shodowMesh;
		let model = null;

		const shadow = new THREE.TextureLoader().load('models/ferrari_ao.png');

		let helper;
		let clock;

		let delelteBtn = document.getElementById("deleteButton")

		document.addEventListener('dragstart', function (event) {
			vanItem = event.target;
			//Hide the default drag image
			event.dataTransfer.setDragImage(document.createElement('div'), 0, 0);

			cloneVanItem = vanItem.cloneNode(true);
			cloneVanItem.style.position = "absolute";
			cloneVanItem.style.display = "none"; // Hide the clone initially
			document.body.appendChild(cloneVanItem);

			switch (event.target.id) {
				case "airconditioner":
					loadItemDirectory = "models/airconditioner.glb";
					break;
				case "maxxair":
					loadItemDirectory = "models/maxxair.glb";
					break;
				case "solar_panel200":
					loadItemDirectory = "models/200W.glb";
					break;
				case "solar_panel50":
					loadItemDirectory = "models/55W.glb";
					break;
				case "solar_panel30":
					loadItemDirectory = "models/30W.glb";
					break;
				default:
					loadItemDirectory = "models/solar_100.glb";
					break;
			}
			const loader = new GLTFLoader();
			loader.load(loadItemDirectory, function (gltf) {
				model = gltf.scene;
			});
		});
		document.addEventListener('dragover', function (event) {
			let a = 2 * event.clientX / window.innerWidth - 1;
			let b = 1 - 2 * event.clientY / window.innerHeight;

			raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
			intersects = raycaster.intersectObjects([workPlane]);
			if (intersects.length > 0) {

				event.preventDefault();
				cloneVanItem.style.display = "none";

				let item = intersects[0];
				let objectHit = item.object;

				let locationX = item.point.x;
				let locationZ = item.point.z;
				let coords = new THREE.Vector3(locationX, 0, locationZ);
				scene.worldToLocal(coords);

				// if (event.target.id === 'airconditioner') {
				if (model) {
					scene.remove(model);
				}
				// else {
				model.position.x = coords.x;
				model.position.y = 2.35;
				// model.position.z = coords.z;
				model.position.z = 0;
				scene.add(model);

			} else {
				// Update the position of the clone based on the mouse cursor position
				cloneVanItem.style.display = "block";
				cloneVanItem.style.left = event.clientX + 'px';
				cloneVanItem.style.top = event.clientY + 'px';
				cloneVanItem.style.transform = "translate(-50%,-50%)";
				if (model) {
					scene.remove(model);
				}
			}
		});

		document.addEventListener('dragend', function (event) {
			if (cloneVanItem) {
				document.body.removeChild(cloneVanItem);
			}
			if (model) {
				scene.remove(model);
			}
			event.preventDefault();
			let a = 2 * event.clientX / window.innerWidth - 1;
			let b = 1 - 2 * event.clientY / window.innerHeight;

			raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
			intersects = raycaster.intersectObjects([workPlane]);

			if (intersects.length == 0) {
				return false;
			}
			else {
				let item = intersects[0];
				let objectHit = item.object;

				let locationX = item.point.x;
				let locationZ = item.point.z;
				let coords = new THREE.Vector3(locationX, 0, locationZ);
				scene.worldToLocal(coords);

				const loader = new GLTFLoader();

				loader.load(loadItemDirectory, function (gltf) {
					const solar100Model = gltf.scene;
					solar100Model.position.x = coords.x;
					solar100Model.position.y = 2.35;
					// solar100Model.position.z = coords.z;
					solar100Model.position.z = 0;
					scene.add(solar100Model);
				});
				render();
			}
			isDragging = false;
		});

		canvasContainer.addEventListener('mousedown', (event) => {
			if (event.button === 0) {
				isDragging = true;
				doMouseDown(event.clientX, event.clientY);
			}
		});

		canvasContainer.addEventListener('mousemove', (event) => {
			if (selectedFeature) {
				if (selectedFeature.parent.name !== "van") {
					if (isDragging) {
						// Create two box geometries
						// const geometry1 = new THREE.BoxGeometry();
						// const geometry2 = new THREE.BoxGeometry();

						// // Create two materials
						// const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
						// const material2 = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

						// // Create two mesh objects
						// const object1 = new THREE.Mesh(geometry1, material1);
						// const object2 = new THREE.Mesh(geometry2, material2);

						// // Position the objects
						// object1.position.set(0, 2.5, 0);
						// object2.position.set(-2, 2.5, 0);

						// // Add objects to the scene
						// scene.add(object1);
						// scene.add(object2);

						// // Create bounding boxes for the objects
						// const selectedFeatureBoundingBox = new THREE.Box3().setFromObject(selectedFeature);
						// const object1BoundingBox = new THREE.Box3().setFromObject(object1);
						// const object2BoundingBox = new THREE.Box3().setFromObject(object2);

						// const collidableMeshList = [object1BoundingBox, object2BoundingBox];

						// let collider = false;
						// collider = collision(selectedFeatureBoundingBox, collidableMeshList);

						let a = 2 * event.clientX / window.innerWidth - 1;
						let b = 1 - 2 * event.clientY / window.innerHeight;
						raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
						intersects = raycaster.intersectObject(targetForDragging);
						if (intersects.length === 0) {
							return;
						}

						let objectHit = intersects[0].object;
						let locationX = intersects[0].point.x;
						let locationZ = intersects[0].point.z;
						let coords = new THREE.Vector3(locationX, 0, locationZ);
						coords = scene.worldToLocal(coords);
						// a = Math.min(0.066, Math.max(-2.2, coords.x));

						const boundingBox = new THREE.Box3().setFromObject(selectedFeature);
						const size = new THREE.Vector3();
						boundingBox.getSize(size);

						// Extract the width from the dimensions
						const selectedFeatureWidth = size.x;

						console.log(coords.x)
						a = Math.min(0.428 - selectedFeatureWidth / 2, Math.max(-2.2, coords.x));
						// b = Math.min(0.32, Math.max(-0.32, coords.z));

						// new THREE.BoxGeometry(3, 0.01, 1.55),
						// 	new THREE.MeshLambertMaterial({ color: "green" })
						// );
						// // workPlane.material.visible = false;

						// workPlane.position.set(-1.08, 2.37, 0);


						// if (collider) {
						// 	let temp = a;
						// 	console.log("temp", temp);
						// 	// if (a >= 0)
						// 	a = Math.min(-0.8, Math.max(-2.2, coords.x));
						// 	// else
						// 	// 	a = Math.min(0.1, Math.max(-1, coords.x));
						// }
						// else {
						// 	a = Math.min(0.1, Math.max(-2.2, coords.x));
						// }
						selectedFeature.parent.position.x = a;
						selectedFeature.parent.position.z = 0;

						render();
					}
				}
				controls.enableRotate = false;
			}
			else {
				controls.enableRotate = true;
			}
		});
		canvasContainer.addEventListener('mouseup', () => {
			isDragging = false;
		});

		document.getElementById('deleteButton').addEventListener('click', function () {
			if (selectedFeature) {
				scene.remove(selectedFeature.parent); // Remove the selected feature from the scene
				this.style.display = "none";
				render();
				selectedFeature = null; // Reset the selected feature
				// document.getElementById('deleteButton').style.display = 'none'; // Hide the delete button
			}
		});

		document.getElementById('camChangeBtn').addEventListener('click', function () {
			const cameraPosition = camera.position;

			if (cameraType === "perspective") {
				camera = new THREE.OrthographicCamera(-window.innerWidth / 340, window.innerWidth / 340, window.innerHeight / 340, -window.innerHeight / 340, 1, 10000);
				cameraType = "orthographic"
			}
			else {
				camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
				cameraType = "perspective"
			}
			camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
			setCameraView();
			setViewCube()
		});
		function doMouseDown(x, y) {
			controls.enableRotate = false;
			if (selectedFeature) {
				removeEdgeLines(selectedFeature);
				selectedFeature = null;
			}
			// if (targetForDragging.parent == scene) {
			scene.remove(targetForDragging);  // I don't want to check for hits on targetForDragging
			// }
			delelteBtn.style.display = "none";

			let a = 2 * x / window.innerWidth - 1;
			let b = 1 - 2 * y / window.innerHeight;
			raycaster.setFromCamera(new THREE.Vector2(a, b), camera);
			intersects = raycaster.intersectObjects(scene.children);  // no need for recusion since all objects are top-level
			if (intersects.length == 0) {
				return false;
			}
			let item = intersects[0];
			let objectHit = item.object;
			if (objectHit.parent &&
				objectHit.parent.name != "van" &&
				objectHit != workPlane &&
				objectHit != shodowMesh) {
				scene.add(targetForDragging);
				targetForDragging.position.set(0, item.point.y, 0);

				// Add or remove edge lines based on selection
				if (objectHit != selectedFeature) {
					selectedFeature = objectHit;
					addEdgeLines(selectedFeature);
					delelteBtn.style.display = "flex";
				}
				else {
					selectedFeature = null;
					removeEdgeLines(selected);
					delelteBtn.style.display = "none";
				}

				render();
			}


		}

		document.addEventListener('DOMContentLoaded', function () {
			canvas = document.querySelector('canvas[data-engine="three.js r162"]');
		});

		function addEdgeLines(object) {
			// Remove existing edge line if it exists
			if (edgeLine) {
				object.remove(edgeLine);
				edgeLine.geometry.dispose();
				edgeLine.material.dispose();
			}

			// Create new edge lines
			const edges = new THREE.EdgesGeometry(object.geometry);
			edgeLine = new THREE.LineSegments(edges, lineMaterial);
			object.add(edgeLine);
		}

		function removeEdgeLines(object) {
			if (edgeLine) {
				object.remove(edgeLine);
				edgeLine.geometry.dispose();
				edgeLine.material.dispose();
				edgeLine = null;
			}
		}

		function collision(selectedFeatureBoundingBox, collidableMeshList) {
			// Check for collisions with each bounding box in the array
			let collisionDetected = false;
			for (const boundingBox of collidableMeshList) {
				if (selectedFeatureBoundingBox.intersectsBox(boundingBox)) {
					collisionDetected = true;
					break; // Exit the loop if collision is detected
				}
			}

			if (collisionDetected) {
				console.log("Collision detected!");
			} else {
				console.log("No collision");
			}

			return collisionDetected;
		}

		function setViewCube() {
			clock = new THREE.Clock();
			// helper
			helper = new ViewHelper(camera, renderer.domElement);
			helper.controls = controls;
			helper.controls.center = controls.target;

			const div = document.createElement('div');
			div.id = 'viewHelper';
			div.style.position = 'absolute';
			div.style.right = 0;
			div.style.bottom = 0;
			div.style.height = '128px';
			div.style.width = '128px';

			document.body.appendChild(div);
			div.addEventListener('pointerup', (event) => (helper.handleClick(event)));
			animate();
		}
		function animate() {
			requestAnimationFrame(animate);
			const delta = clock.getDelta();
			if (helper.animating) helper.update(delta);
			helper.render(renderer);
		}
		function setCameraView() {
			controls = new OrbitControls(camera, container);

			controls.maxDistance = 20;
			controls.minDistance = 3;

			controls.maxZoom = 3;
			controls.minZoom = 0.5;

			controls.maxPolarAngle = THREE.MathUtils.degToRad(90);

			controls.target.set(0, 0.5, 0);
		}

		function init() {
			const container = document.getElementById('container');

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(render);
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 0.85;
			renderer.autoClear = false;

			container.appendChild(renderer.domElement);

			window.addEventListener('resize', onWindowResize);

			// Create an OrthographicCamera
			camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
			// camera = new THREE.OrthographicCamera(-window.innerWidth / 340, window.innerWidth / 340, window.innerHeight / 340, -window.innerHeight / 340, 1, 10000);
			camera.position.set(1, 6, 6);
			setCameraView();

			// controls.update();

			scene = new THREE.Scene();
			// scene.environment = new RGBELoader().load('textures/test.hdr');
			scene.background = new THREE.Color("#ffffff");
			// scene.environment.mapping = THREE.EquirectangularReflectionMapping;

			setViewCube();
			// const moonLight = new THREE.DirectionalLight('#1f9ec8', 0.7)
			// scene.add(moonLight)

			const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight1.position.set(1, 1, 0);
			scene.add(directionalLight1);

			const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight2.position.set(-1, 1, 0);
			scene.add(directionalLight2);

			const directionalLight3 = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight3.position.set(0, 1, 1);
			scene.add(directionalLight3);

			const directionalLight4 = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight4.position.set(0, 1, -1);
			scene.add(directionalLight4);

			const ambientLight = new THREE.AmbientLight('#ffffff', 1); // color, intensity
			scene.add(ambientLight);

			// renderer.setClearAlpha(0); // Set the alpha value to 0 for transparency
			// scene.fog = new THREE.Fog(0x333333, 10, 15);
			/*grid = new THREE.GridHelper( 20, 40, 0xffffff, 0xffffff );
			grid.material.opacity = 0.2;
			grid.material.depthWrite = false;
			grid.material.transparent = true;
			scene.add( grid );*/

			// materials

			// const bodyMaterial = new THREE.MeshPhysicalMaterial( {
			// 	color: 0xff0000, metalness: 1.0, roughness: 0.5, clearcoat: 1.0, clearcoatRoughness: 0.03
			// } );

			// const detailsMaterial = new THREE.MeshStandardMaterial( {
			// 	color: 0xffffff, metalness: 1.0, roughness: 0.5
			// } );

			// const glassMaterial = new THREE.MeshPhysicalMaterial( {
			// 	color: 0xffffff, metalness: 0.25, roughness: 0, transmission: 1.0
			// } );

			// const bodyColorInput = document.getElementById( 'body-color' );
			// bodyColorInput.addEventListener( 'input', function () {

			// 	bodyMaterial.color.set( this.value );

			// } );

			// const detailsColorInput = document.getElementById( 'details-color' );
			// detailsColorInput.addEventListener( 'input', function () {

			// 	detailsMaterial.color.set( this.value );

			// } );

			// const glassColorInput = document.getElementById( 'glass-color' );
			// glassColorInput.addEventListener( 'input', function () {

			// 	glassMaterial.color.set( this.value );

			// } );

			const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

			loader.load('models/van1.glb', function (gltf) {
				carModel = gltf.scene;
				// carModel.getObjectByName( 'body' ).material = bodyMaterial;
				// carModel.getObjectByName( 'rim_fl' ).material = detailsMaterial;
				// carModel.getObjectByName( 'rim_fr' ).material = detailsMaterial;
				// carModel.getObjectByName( 'rim_rr' ).material = detailsMaterial;
				// carModel.getObjectByName( 'rim_rl' ).material = detailsMaterial;
				// carModel.getObjectByName( 'trim' ).material = detailsMaterial;
				// carModel.getObjectByName( 'glass' ).material = glassMaterial;
				// wheels.push(
				// 	// carModel.getObjectByName( 'wheel_fl' ),
				// 	// carModel.getObjectByName( 'wheel_fr' ),
				// 	// carModel.getObjectByName( 'wheel_rl' ),
				// 	carModel.getObjectByName( 'wheel_rr' )
				// );

				// shadow
				shodowMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(2.8, 6.5),
					new THREE.MeshBasicMaterial({
						map: shadow, blending: THREE.MultiplyBlending, toneMapped: false, transparent: true
					})
				);
				shodowMesh.rotation.x = - Math.PI / 2;
				shodowMesh.rotation.z = Math.PI / 2;
				shodowMesh.renderOrder = 2;
				carModel.add(shodowMesh);

				scene.add(carModel);

				workPlane = new THREE.Mesh(
					new THREE.BoxGeometry(3, 0.01, 1.55),
					new THREE.MeshLambertMaterial({ color: "green" })
				);
				workPlane.material.visible = false;

				workPlane.position.set(-1.08, 2.37, 0); // Set position
				scene.add(workPlane);

				targetForDragging = new THREE.Mesh(
					new THREE.BoxGeometry(100, 0.01, 100),
					new THREE.MeshBasicMaterial()
				);
				targetForDragging.material.visible = false;

				raycaster = new THREE.Raycaster();
			});
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function render() {
			controls.update();
			// const time = - performance.now() / 1000;
			// for (let i = 0; i < wheels.length; i++) {
			// 	wheels[i].rotation.x = time * Math.PI * 2;
			// }
			//grid.position.z = - ( time ) % 1;
			renderer.render(scene, camera);
		}

		init();

	</script>
</body>

</html>