<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Van</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		* {
			overflow-x: hidden !important;

		}

		body {
			width: 100%;
			height: 100%;
			overflow: hidden !important;
			margin: 0;
			padding: 0;
		}

		.canvasID {
			width: 100%;
			height: 100%;
			overflow: hidden !important;
			position: fixed;
			top: 0;
			left: 0;
			outline: none;
		}

		h2 {
			position: absolute;
			color: #ce3fbb;
			width: 100%;
			text-align: center;
			top: 78%;
			font-size: 1.8em;
		}
	</style>
</head>

<body>
	<canvas class="canvasID">
	</canvas>
	<!-- <div id="info">
			Ferrari 458 Italia model
			<br><br>
			<span class="colorPicker"><input id="body-color" type="color" value="#ff0000"></input><br/>Body</span>
			<span class="colorPicker"><input id="details-color" type="color" value="#ffffff"></input><br/>Details</span>
			<span class="colorPicker"><input id="glass-color" type="color" value="#ffffff"></input><br/>Glass</span>
		</div> -->

	<div id="container"></div>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
	<script type="module">

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';

		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

		const canvasID = document.querySelector('.canvasID')
		const scene = new THREE.Scene()
		// texture loader
		const texLoad = new THREE.TextureLoader()
		// renderer
		const renderer = new THREE.WebGLRenderer({
			canvas: canvasID, antialias: true
		})
		renderer.setSize(window.innerWidth, window.innerHeight)
		//set background color
		renderer.setClearColor('#bae8ff', .97);
		// screen size
		const sizes = {
			width: window.innerWidth,
			height: window.innerHeight
		}

		// Resize function
		window.addEventListener('resize', () => {
			sizes.width = window.innerWidth
			sizes.height = window.innerHeight

			// update the camera
			camera.aspect = sizes.width / sizes.height
			camera.updateProjectionMatrix()

			// update renderer
			renderer.setSize(window.innerWidth, window.innerHeight)
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
		})

		const aspectRatio = sizes.width / sizes.height
		// camera
		const camera = new THREE.PerspectiveCamera(75, aspectRatio, 5, 150)
		scene.add(camera)

		const cursor = {
			x: 0,
			y: 0
		}
		window.addEventListener('mousemove', (event) => {

			cursor.x = event.clientX / window.innerWidth - 0.5

			// the minus is changing the direction to be logical
			cursor.y = - (event.clientY / window.innerHeight - 0.5)


		})
		// Fog
		const fog = new THREE.Fog('#fafafa', 25.5024, 200)
		scene.fog = fog

		// The house declartion
		// The Lights
		// Ambient light
		const ambientLight = new THREE.AmbientLight('#ffffff', 1)

		scene.add(ambientLight)

		const moonLight = new THREE.DirectionalLight('#1f9ec8', 0.7)

		scene.add(moonLight)
		const boxGeometry = new THREE.BoxGeometry(1, 1, 1)

		const boxMaterial1 = new THREE.MeshStandardMaterial({
			metalness: 0.3,
			roughness: 0.4,
			color: '#ffff00'
		})

		const fanMaterial = new THREE.MeshStandardMaterial({
			metalness: 0.3,
			roughness: 0.4,
			color: '#ff0fff'
		})

		const tableMaterial = new THREE.MeshStandardMaterial({
			metalness: 0.3,
			roughness: 0.4,

			color: '#ffff00'
		})

		//Cannon.js
		const world = new CANNON.World()
		world.broadphase = new CANNON.SAPBroadphase(world)
		world.allowSleep = false

		world.gravity.set(0, -800, 0)

		// materials
		const defaultMaterial = new CANNON.Material('default')

		const defaultContactMaterial = new CANNON.ContactMaterial(
			defaultMaterial,
			defaultMaterial,
			{
				friction: 5.51,
				restitution: 0.05

			}
		)
		world.addContactMaterial(defaultContactMaterial)
		world.defaultContactMaterial = defaultContactMaterial


		// ARRAYS
		const objToUpdatePlayers = []
		const FloorToUpdate = []
		const objToUpdateTable = []
		const objToUpdateFan = []

		const createTable = (width, height, depth, position) => {
			// first three.js mesh

			// Three.js mesh
			const mesh = new THREE.Mesh(boxGeometry, tableMaterial)
			mesh.scale.set(width, height, depth)
			mesh.castShadow = true
			mesh.position.copy(position)
			scene.add(mesh)

			// Cannon.js body
			const shape = new CANNON.Box(new CANNON.Vec3(width * 0.5, height * 0.5, depth * 0.5))

			const body = new CANNON.Body({
				mass: 1000,
				position: new CANNON.Vec3(0, 0, 0),
				shape: shape,
				material: defaultMaterial
			})
			body.position.copy(position)
			world.addBody(body)

			// save in update array
			objToUpdateTable.push({
				mesh: mesh,
				body: body
			})
		}
		const createFan = (width, height, depth, position) => {
			// first three.js mesh

			// Three.js mesh
			const mesh = new THREE.Mesh(boxGeometry, fanMaterial)
			mesh.scale.set(width, height, depth)
			mesh.castShadow = true
			mesh.position.copy(position)
			scene.add(mesh)

			// Cannon.js body
			const shape = new CANNON.Box(new CANNON.Vec3(width * 0.5, height * 0.5, depth * 0.5))

			const body = new CANNON.Body({
				mass: 1000,
				position: new CANNON.Vec3(0, 0, 0),
				shape: shape,
				material: defaultMaterial
			})
			body.position.copy(position)
			world.addBody(body)

			// save in update array
			objToUpdateFan.push({
				mesh: mesh,
				body: body
			})
		}
		// ball
		const sphereGeometry = new THREE.SphereGeometry(1, 20, 20)
		const sphereMaterial = new THREE.MeshStandardMaterial({
			metalness: 0.3,
			roughness: 0.4,
			color: '#dbf3ff'
		})
		const createSphere = (radius, position) => {
			// Three.js mesh
			const mesh = new THREE.Mesh(sphereGeometry, sphereMaterial)
			mesh.castShadow = true
			mesh.scale.set(radius, radius, radius)
			mesh.position.copy(position)
			scene.add(mesh)

			// Cannon.js body
			const shape = new CANNON.Sphere(radius)

			const body = new CANNON.Body({
				mass: 10,
				position: new CANNON.Vec3(0, 48, 0),
				shape: shape,
				material: defaultMaterial
			})
			body.position.copy(position)
			world.addBody(body)

			// Save in objects
			objToUpdatePlayers.push({ mesh, body })
		}
		createSphere(5, { x: 0, y: 48, z: 5.5 })


		document.addEventListener('keydown', function (event) {
			/// object rotate on y-xis
			if (event.code == 'KeyW') {

				objToUpdateFan[0].body.position.y += 5
				objToUpdateFan[0].mesh.position.y -= 5
			}
			if (event.code == 'KeyS') {
				objToUpdateFan[0].body.quaternion.x += .1
				objToUpdateFan[0].mesh.rotation.x -= .1

			}

		})

		document.addEventListener('click', () => {
			objToUpdateFan[0].body.position.y += 5
			objToUpdateFan[0].mesh.position.y -= 5
		})
		//1
		createFan(50, 8, 14, { x: -5, y: 6.5, z: 5.5 })
		createTable(405, .5, 405, { x: 0, y: .5, z: 5 })


		// clock
		const clock = new THREE.Clock()

		//Orbit Controls

		/// camerea positions

		// posiiton A
		camera.position.z = -45
		camera.position.y = 65
		camera.position.x = -4
		camera.rotation.y = 0.6
		camera.rotation.z = 1

		const controls = new OrbitControls(
			camera, canvasID);
		controls.enableDamping = true
		// Floor cannon
		const floorShape = new CANNON.Plane()
		const floorBody = new CANNON.Body()
		// set object to static
		floorBody.mass = 0
		floorBody.material = defaultMaterial
		floorBody.addShape(floorShape)

		floorBody.quaternion.setFromAxisAngle(
			new CANNON.Vec3(-1, 0, 0),
			Math.PI * .5
		)

		world.addBody(floorBody)
		// Floor
		const floor = new THREE.Mesh(
			new THREE.PlaneGeometry(15, 15),
			new THREE.MeshStandardMaterial({ color: '#2e0c09' })
		)
		floor.rotation.x = - Math.PI * 0.5
		floor.position.y = -1
		scene.add(floor)
		// var tl = gsap.timeline({ease:'Power1.inOut',stagger:0.001});


		// time has passed
		const elpasedTime = clock.getElapsedTime()
		let lastTime = 0
		let anima


		function anim() {
			// time of clock
			renderer.render(scene, camera)
			const elpasedTime = clock.getElapsedTime()
			const deltaTime = elpasedTime - lastTime
			lastTime = elpasedTime
			// cannon update world func
			world.step(1 / 60, deltaTime, 3)

			// for of function
			camera.updateProjectionMatrix()


			for (const object of FloorToUpdate) {

				object.mesh.position.copy(object.body.position)

			}



			for (const object of objToUpdatePlayers) {

				object.mesh.position.copy(object.body.position)

			}

			for (const object of objToUpdateFan) {

				object.mesh.position.copy(object.body.position)

			}

			anima = requestAnimationFrame(anim)
		}
		anim()

	</script>
</body>

</html>